{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Autoimport","text":"<p>Autoimport missing python libraries.</p> <p>Throughout the development of a python program you continuously need to manage the python import statements either because you need one new object or because you no longer need it. This means that you need to stop writing whatever you were writing, go to the top of the file, create or remove the import statement and then resume coding.</p> <p>This workflow break is annoying and almost always unnecessary. <code>autoimport</code> solves this problem if you execute it whenever you have an import error, for example by configuring your editor to run it when saving the file.</p>"},{"location":"#installing","title":"Installing","text":"<pre><code>pip install autoimport\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Imagine we've got the following source code:</p> <pre><code>import requests\n\n\ndef hello(names: Tuple[str]) -&gt; None:\n    for name in names:\n        print(f\"Hi {name}!\")\n\n\nos.getcwd()\n</code></pre> <p>It has the following import errors:</p> <ul> <li><code>requests</code> is imported but unused.</li> <li><code>os</code> and <code>Tuple</code> are needed but not imported.</li> </ul> <p>After running <code>autoimport</code> the resulting source code will be:</p> <pre><code>import os\nfrom typing import Tuple\n\n\ndef hello(names: Tuple[str]) -&gt; None:\n    for name in names:\n        print(f\"Hi {name}!\")\n\n\nos.getcwd()\n</code></pre> <p><code>autoimport</code> can be used both as command line tool and as a library.</p> <p>It can be parsed either an array of files and/or a directory.</p> <p>A parsed directory will have <code>autoimport</code> be executed on all recursively found python files in said directory.</p> <ul> <li>As a command line tool:</li> </ul> <pre><code>$: autoimport file.py\n$: autoimport dir/\n</code></pre> <ul> <li>As a library:</li> </ul> <pre><code>from autoimport import fix_files\n\nfix_files([\"file.py\", \"dir/\"])\n</code></pre> <p>Warning: <code>autoimport</code> will add all dependencies at the top of the file, we suggest using isort and black afterwards to clean the file.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#add-missing-imports","title":"Add missing imports","text":"<p><code>autoimport</code> matches each of the missing import statements against the following objects:</p> <ul> <li> <p>The modules referenced in <code>PYTHONPATH</code>.</p> </li> <li> <p>The <code>typing</code> library objects.</p> </li> <li> <p>The common statements. Where some of the common statements are:</p> </li> <li> <p><code>BeautifulSoup</code> -&gt; <code>from bs4 import BeautifulSoup</code></p> </li> <li><code>call</code> -&gt; <code>from unittest.mock import call</code></li> <li><code>CaptureFixture</code> -&gt; <code>from _pytest.capture import CaptureFixture</code></li> <li><code>CliRunner</code> -&gt; <code>from click.testing import CliRunner</code></li> <li><code>copyfile</code> -&gt; <code>from shutil import copyfile</code></li> <li><code>dedent</code> -&gt; <code>from textwrap import dedent</code></li> <li><code>LocalPath</code> -&gt; <code>from py._path.local import LocalPath</code></li> <li><code>LogCaptureFixture</code> -&gt; <code>from _pytest.logging import LogCaptureFixture</code></li> <li><code>Mock</code> -&gt; <code>from unittest.mock import Mock</code></li> <li><code>patch</code> -&gt; <code>from unittest.mock import patch</code></li> <li><code>StringIO</code> -&gt; <code>from io import StringIO</code></li> <li> <p><code>YAMLError</code> -&gt; <code>from yaml import YAMLError</code></p> </li> <li> <p>The objects of the Python project you are developing, assuming you are   executing the program in a directory of the project and you can import it.</p> </li> </ul> <p>Warning: It may not work if you use <code>pip install -e .</code>. Given that you execute <code>autoimport</code> inside a virtualenv where the package is installed with <code>pip install -e .</code>, when there is an import error in a file that is indexed in the package, <code>autoimport</code> won't be able to read the package contents as the <code>import</code> statement will fail. So it's a good idea to run autoimport from a virtualenv that has a stable version of the package we are developing.</p>"},{"location":"#remove-unused-import-statements","title":"Remove unused import statements","text":"<p>If an object is imported but unused, <code>autoimport</code> will remove the import statement.</p> <p>This can be problematic when run in <code>__init__.py</code> files, which often contain \"unused\" imports. To tell <code>autoimport</code> to not run on these files, you can use the <code>--ignore-init-modules</code> flag, which will filter away any passed <code>__init__.py</code> files before processing.</p> <p>There may be import statements that are being used dynamically,  to autoimport it would look like those are not being used but actually they may have some usages.</p> <p>In such cases where you want to retain the unused imports across any file, you can use the <code>--keep-unused-imports</code> flag,  which will prevent <code>autoimport</code> from removing any import statements. </p> <p>Note: If there are not many cases where you intend to keep the unused imports, prefer placing  <code>#noqa: autoimport</code> on the concerned import line/s, over using the <code>--keep-unused-imports</code> flag.</p>"},{"location":"#moving-the-imports-to-the-top","title":"Moving the imports to the top","text":"<p>There are going to be import cases that may not work, if you find one, please open an issue.</p> <p>While we fix it you can write the import statement wherever you are in the file and the next time you run <code>autoimport</code> it will get moved to the top.</p> <p>If you don't want a specific line to go to the top, add the <code># noqa: autoimport</code> or <code># fmt: skip</code> at the end. For example:</p> <pre><code>a = 1\n\nfrom os import getcwd  # noqa: autoimport\n\ngetcwd()\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p><code>autoimport</code> uses the <code>maison</code> library to discover and read your project-local <code>pyproject.toml</code> file (if it exists). This file can be used to configure <code>autoimport</code>'s behavior: the <code>tool.autoimport.common_statements</code> table in that file can be used to define a custom set of \"common statements\", overriding the default set of common statements mentioned above. For example:</p> <pre><code># pyproject.toml\n\n[tool.autoimport.common_statements]\n\"np\" = \"import numpy as np\"\n\"FooBar\" = \"from baz_qux import FooBar\"\n</code></pre> <p>It is also possible to specify a different path for this config file:</p> <pre><code>$: autoimport --config-file ~/.autoimport.toml file.py\n</code></pre> <p>If using the <code>--config-file</code> flag to specify a file that is named something other than <code>pyproject.toml</code>, the autoimport settings should not be nested under toplevel <code>tool.autoimport</code> keys.</p> <pre><code># .autoimport.toml\n\n[common_statements]\n\"np\" = \"import numpy as np\"\n\"FooBar\" = \"from baz_qux import FooBar\"\n</code></pre> <p>Furthermore, <code>autoimport</code> supports the use of a global configuration file, located at <code>autoimport/config.toml</code> under the xdg config home folder. For most users, this means that the file <code>~/.config/autoimport/config.toml</code>, if it exists, will be loaded and used as configuration for <code>autoimport</code>. As before, do not write <code>tool.autoimport</code> at the toplevel; just specify your global <code>autoimport</code> settings directly.</p> <p>The settings defined in the local <code>pyproject.toml</code> file (if found) or in the file specified by the <code>--config-file</code> flag (if given) will override the settings defined in the global <code>autoimport/config.toml</code> file.</p>"},{"location":"#disabling-move-to-top","title":"Disabling Move To Top","text":"<p>While discouraged in favor of proper refactoring to eliminate cyclical dependencies, it is possible to disable autoimport from moving import statements to the tops of the files.</p> <p>To do so, set <code>disable_move_to_top</code> to <code>true</code>. Here is how that might look in a <code>pyproject.toml</code> configuration file.</p> <pre><code>[tool.autoimport]\ndisable_move_to_top = true\n</code></pre>"},{"location":"#references","title":"References","text":"<p>As most open sourced programs, <code>autoimport</code> is standing on the shoulders of giants, namely:</p> <ul> <li>autoflake: Inspiration of <code>autoimport</code>.   Also used their code to interact with</li> <li>pyflakes.</li> <li>Click: Used to create the command line   interface.</li> <li>Pytest: Testing framework, enhanced by   the awesome pytest-cases   library that made the parametrization of the tests a lovely experience.</li> <li>Mypy: Python static type checker.</li> <li>Flakeheaven: Python linter with   lots of checks.</li> <li>Black: Python formatter to keep a   nice style without effort.</li> <li>Autoimport: Python formatter to   automatically fix wrong import statements.</li> <li>isort: Python formatter to order   the import statements.</li> <li>PDM: Command line tool to manage the dependencies.</li> <li>Mkdocs: To build this documentation site, with the</li> <li>Material theme.</li> <li>Safety: To check the installed   dependencies for known security vulnerabilities.</li> <li>Bandit: To finds common security   issues in Python code.</li> <li>Yamlfix: YAML fixer.</li> </ul>"},{"location":"#alternatives","title":"Alternatives","text":"<p>If you like the idea but not how we solved the problem, take a look at this other solutions:</p> <ul> <li>smart-imports</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>For guidance on setting up a development environment, and how to make a contribution to autoimport, see Contributing to autoimport.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>So you've started using <code>autoimport</code> and want to show your gratitude to the project, depending on your programming skills there are different ways to do so.</p>"},{"location":"contributing/#i-dont-know-how-to-program","title":"I don't know how to program","text":"<p>There are several ways you can contribute:</p> <ul> <li>Open an issue if you encounter     any bug or to let us know if you want a new feature to be implemented.</li> <li>Spread the word about the program.</li> <li>Review the documentation and try to improve     it.</li> </ul>"},{"location":"contributing/#i-know-how-to-program-in-python","title":"I know how to program in Python","text":"<p>If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones, check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues, as they are expected to be easier to get into the project.</p> <p>We develop the program with TDD, so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it.</p> <p>We know that the expected code quality is above average. Therefore it might be challenging to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing:</p> <ul> <li>If you want to develop a new feature, explain how you'd like to do it in the related issue.</li> <li>If you don't know how to test your code, do the pull request without the tests     and we'll try to do them for you.</li> </ul>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead.</p> <p>To make it as simple as possible for us to help you, please include the output of the following call in your issue:</p> <pre><code>python -c \"import autoimport.version; print(autoimport.version.version_info())\"\n</code></pre> <p>or if you have <code>make</code> installed, you can use <code>make version</code>.</p> <p>Please try to always include the above unless you're unable to install <code>autoimport</code> or know it's not relevant to your question or feature request.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>autoimport is released regularly so you should see your improvements release in a matter of days or weeks.</p> <p>Note</p> <p>Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request.</p> <p>If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.</p>"},{"location":"contributing/#development-facilities","title":"Development facilities","text":"<p>To make contributing as easy and fast as possible, you'll want to run tests and linting locally.</p> <p>tl;dr: use <code>make format</code> to fix formatting, <code>make</code> to run tests and linting &amp; <code>make docs</code> to build the docs.</p> <p>You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed.</p> <ul> <li> <p>Clone your fork and go into the repository directory:</p> <pre><code>git clone git@github.com:&lt;your username&gt;/autoimport.git\ncd autoimport\n</code></pre> </li> <li> <p>Set up the virtualenv for running tests:</p> <pre><code>virtualenv -p `which python3.7` env\nsource env/bin/activate\n</code></pre> </li> <li> <p>Install autoimport, dependencies and configure the     pre-commits:</p> <pre><code>make install\n</code></pre> </li> <li> <p>Checkout a new branch and make your changes:</p> <pre><code>git checkout -b my-new-feature-branch\n</code></pre> </li> <li> <p>Fix formatting and imports: autoimport uses     black to enforce formatting and     isort to fix imports.</p> <pre><code>make format\n</code></pre> </li> <li> <p>Run tests and linting:</p> <pre><code>make\n</code></pre> <p>There are more sub-commands in Makefile like <code>test-code</code>, <code>test-examples</code>, <code>mypy</code> or <code>security</code> which you might want to use, but generally <code>make</code> should be all you need.</p> <p>If you need to pass specific arguments to pytest use the <code>ARGS</code> variable, for example <code>make test ARGS='-k test_markdownlint_passes'</code>.</p> </li> <li> <p>Build documentation: If you have changed the documentation, make sure it     builds the static site. Once built it will serve the documentation at     <code>localhost:8000</code>:</p> <pre><code>make docs\n</code></pre> </li> <li> <p>Commit, push, and create your pull request.</p> </li> </ul> <p>We'd love you to contribute to autoimport!</p>"},{"location":"editor_integration/","title":"Editor integration","text":"<p>For a smoother experience, you can run <code>autoimport</code> automatically each time you save your file in your editor or when you run <code>git commit</code>.</p>"},{"location":"editor_integration/#vim","title":"Vim","text":"<p>To integrate <code>autoimport</code> into Vim, I recommend using the ale plugin.</p> <p>If you are new to ALE, check this post.</p> <p><code>ale</code> is configured to run <code>autoimport</code> automatically by default.</p>"},{"location":"editor_integration/#pre-commit","title":"pre-commit","text":"<p>You can run <code>autoimport</code> before we do a commit using the pre-commit framework. If you don't know how to use it, follow these guidelines.</p> <p>You'll need to add the following lines to your project's <code>.pre-commit-config.yaml</code> file.</p> <pre><code>repos:\n  - repo: https://github.com/lyz-code/autoimport/\n    rev: master\n    hooks:\n      - id: autoimport\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>Define all the orchestration functionality required by the program to work.</p> <p>Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose.</p> <p>Define the different ways to expose the program functionality.</p> Functions <p>Utilities to retrieve the information of the program version.</p>"},{"location":"reference/#autoimport.services.fix_code","title":"<code>fix_code(original_source_code, config=None, keep_unused_imports=False)</code>","text":"<p>Fix python source code to correct import statements.</p> It corrects these errors <ul> <li>Add missed import statements.</li> <li>Remove unused import statements.</li> <li>Move import statements to the top.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>original_source_code</code> <code>str</code> <p>Source code to be corrected.</p> required <code>keep_unused_imports</code> <code>bool</code> <p>If true, unused imports are retained.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Corrected source code.</p> Source code in <code>autoimport/services.py</code> <pre><code>def fix_code(\n    original_source_code: str,\n    config: Optional[Dict[str, Any]] = None,\n    keep_unused_imports: bool = False,\n) -&gt; str:\n    \"\"\"Fix python source code to correct import statements.\n\n    It corrects these errors:\n\n        * Add missed import statements.\n        * Remove unused import statements.\n        * Move import statements to the top.\n\n    Args:\n        original_source_code: Source code to be corrected.\n        keep_unused_imports: If true, unused imports are retained.\n\n    Returns:\n        Corrected source code.\n    \"\"\"\n    return SourceCode(\n        original_source_code, config=config, keep_unused_imports=keep_unused_imports\n    ).fix()\n</code></pre>"},{"location":"reference/#autoimport.services.fix_files","title":"<code>fix_files(files, config=None, keep_unused_imports=False)</code>","text":"<p>Fix the python source code of a list of files.</p> <p>If the input is taken from stdin, it will output the value to stdout.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Tuple[TextIOWrapper, ...]</code> <p>List of files to fix.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Fixed code retrieved from stdin or None.</p> Source code in <code>autoimport/services.py</code> <pre><code>def fix_files(\n    files: Tuple[TextIOWrapper, ...],\n    config: Optional[Dict[str, Any]] = None,\n    keep_unused_imports: bool = False,\n) -&gt; Optional[str]:\n    \"\"\"Fix the python source code of a list of files.\n\n    If the input is taken from stdin, it will output the value to stdout.\n\n    Args:\n        files: List of files to fix.\n\n    Returns:\n        Fixed code retrieved from stdin or None.\n    \"\"\"\n    for file_wrapper in files:\n        source = file_wrapper.read()\n        fixed_source = fix_code(source, config, keep_unused_imports)\n\n        if fixed_source == source and file_wrapper.name != \"&lt;stdin&gt;\":\n            continue\n\n        try:\n            # Click testing runner doesn't simulate correctly the reading from stdin\n            # instead of setting the name attribute to `&lt;stdin&gt;` it gives an\n            # AttributeError. But when you use it outside testing, no AttributeError\n            # is raised and name has the value &lt;stdin&gt;. So there is no way of testing\n            # this behaviour.\n            if file_wrapper.name == \"&lt;stdin&gt;\":  # pragma no cover\n                output = \"output\"\n            else:\n                output = \"file\"\n        except AttributeError:\n            output = \"output\"\n\n        if output == \"file\":\n            file_wrapper.seek(0)\n            file_wrapper.write(fixed_source)\n            file_wrapper.truncate()\n            file_wrapper.close()\n        else:\n            return fixed_source\n\n    return None\n</code></pre>"},{"location":"reference/#autoimport.entrypoints.load_logger","title":"<code>load_logger(verbose=False)</code>","text":"<p>Configure the Logging logger.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Set the logging level to Debug.</p> <code>False</code> Source code in <code>autoimport/entrypoints/__init__.py</code> <pre><code>def load_logger(verbose: bool = False) -&gt; None:  # pragma no cover\n    \"\"\"Configure the Logging logger.\n\n    Args:\n        verbose: Set the logging level to Debug.\n    \"\"\"\n    logging.addLevelName(logging.INFO, \"[\\033[36m+\\033[0m]\")\n    logging.addLevelName(logging.ERROR, \"[\\033[31m+\\033[0m]\")\n    logging.addLevelName(logging.DEBUG, \"[\\033[32m+\\033[0m]\")\n    logging.addLevelName(logging.WARNING, \"[\\033[33m+\\033[0m]\")\n    if verbose:\n        logging.basicConfig(\n            stream=sys.stderr, level=logging.DEBUG, format=\"  %(levelname)s %(message)s\"\n        )\n    else:\n        logging.basicConfig(\n            stream=sys.stderr, level=logging.INFO, format=\"  %(levelname)s %(message)s\"\n        )\n</code></pre>"},{"location":"reference/#autoimport.version.version_info","title":"<code>version_info()</code>","text":"<p>Display the version of the program, python and the platform.</p> Source code in <code>autoimport/version.py</code> <pre><code>def version_info() -&gt; str:\n    \"\"\"Display the version of the program, python and the platform.\"\"\"\n    return dedent(\n        f\"\"\"\\\n        ------------------------------------------------------------------\n             autoimport: {__version__}\n             Python: {sys.version.split(\" \", maxsplit=1)[0]}\n             Platform: {platform.platform()}\n        ------------------------------------------------------------------\"\"\"\n    )\n</code></pre>"},{"location":"adr/adr/","title":"Adr","text":"<p>ADR are short text documents that captures an important architectural decision made along with its context and consequences.</p> <pre><code>graph TD\n    001[001: High level analysis]\n    002[002: Initial Program design]\n\n    001 -- Extended --&gt; 002\n\n    click 001 \"https://lyz-code.github.io/autoimport/adr/001-high_level_problem_analysis\" _blank\n    click 002 \"https://lyz-code.github.io/autoimport/adr/002-initial_program_design\" _blank\n\n    001:::draft\n    002:::draft\n\n    classDef draft fill:#CDBFEA;\n    classDef proposed fill:#B1CCE8;\n    classDef accepted fill:#B1E8BA;\n    classDef rejected fill:#E8B1B1;\n    classDef deprecated fill:#E8B1B1;\n    classDef superseeded fill:#E8E5B1;</code></pre>"}]}